/**
 * R2 Storage Service - Centralized service for all R2 bucket operations
 * Extends BaseService for consistent error handling and logging patterns
 * Provides consistent interface, error handling, and access control
 */

// R2 types are available globally from cloudflare-env.d.ts generated by wrangler
// No need to import from @cloudflare/workers-types as they conflict
import { HTTPException } from 'hono/http-exception';
import * as HttpStatusCodes from 'stoker/http-status-codes';

import {
  asReadableStream,
  convertToR2CustomMetadata,
  parseR2CustomMetadata,
} from '@/api/common/type-utils';
import type { ServiceConfig } from '@/api/patterns/service-factory';
import { BaseService } from '@/api/patterns/service-factory';
import type { Session, User } from '@/lib/auth/types';

export type R2Metadata = {
  userId?: string;
  userName?: string;
  userEmail?: string;
  organizationId?: string;
  uploadedAt: string;
  purpose?: string;
  contentType?: string;
  fileSize?: string;
  originalName?: string;
  type?: string;
  requestId?: string;
  clientIp?: string;
};

export type PutObjectOptions = {
  contentType?: string;
  cacheControl?: string;
  metadata?: R2Metadata;
};

export type ListObjectsResult = {
  objects: Array<{
    key: string;
    size: number;
    etag: string;
    uploaded: string;
    metadata?: R2Metadata;
  }>;
  truncated: boolean;
  cursor?: string;
};

export type AccessCheckResult = {
  hasAccess: boolean;
  accessLevel?: 'owner' | 'organization' | 'public' | 'none';
  reason?: string;
};

export type R2StorageConfig = ServiceConfig & {
  bucket: R2Bucket;
};

/**
 * Centralized R2 Storage Service
 * Extends BaseService for consistent error handling and monitoring
 */
export class R2StorageService extends BaseService<R2StorageConfig> {
  private bucket: R2Bucket;

  constructor(config: R2StorageConfig) {
    super(config);
    this.bucket = config.bucket;

    if (!this.bucket) {
      throw new Error('R2 bucket not initialized');
    }
  }

  /**
   * Get service configuration from environment with validation
   */
  static getConfig(env: CloudflareEnv): R2StorageConfig {
    const bucket = env.UPLOADS_R2_BUCKET;
    if (!bucket) {
      throw new HTTPException(HttpStatusCodes.INTERNAL_SERVER_ERROR, {
        message: 'R2 bucket not bound to environment',
      });
    }

    return {
      serviceName: 'R2-Storage',
      timeout: 60000, // Longer timeout for file operations
      retries: 2,
      circuitBreaker: {
        failureThreshold: 10, // Higher threshold for storage operations
        resetTimeout: 30000,
      },
      bucket,
    };
  }

  /**
   * Upload an object to R2
   * Using BaseService error handling patterns
   */
  async putObject(
    key: string,
    data: ArrayBuffer | ReadableStream,
    options: PutObjectOptions = {},
  ) {
    const logger = this.createOperationLogger('putObject');

    try {
      logger.debug('Uploading object to R2', { key, contentType: options.contentType });

      const httpMetadata: Record<string, string> = {};

      if (options.contentType) {
        httpMetadata.contentType = options.contentType;
      }

      if (options.cacheControl) {
        httpMetadata.cacheControl = options.cacheControl;
      } else {
        // Default cache control for private content
        httpMetadata.cacheControl = 'private, max-age=3600';
      }

      const result = await this.bucket.put(key, data, {
        httpMetadata,
        customMetadata: convertToR2CustomMetadata(options.metadata),
      });

      logger.info('Object uploaded successfully', { key, etag: result?.etag });
      return result;
    } catch (error) {
      logger.error('Failed to upload object', error as Error, { key });
      throw this.handleError(error, 'put object', { key, options });
    }
  }

  /**
   * Get an object from R2
   * Using BaseService error handling patterns
   */
  async getObject(key: string) {
    const logger = this.createOperationLogger('getObject');

    try {
      logger.debug('Retrieving object from R2', { key });

      const result = await this.bucket.get(key);

      if (result) {
        logger.info('Object retrieved successfully', { key, size: result.size });
      } else {
        logger.debug('Object not found', { key });
      }

      return result;
    } catch (error) {
      logger.error('Failed to retrieve object', error as Error, { key });
      throw this.handleError(error, 'get object', { key });
    }
  }

  /**
   * Get object metadata without downloading the content
   */
  async headObject(key: string) {
    try {
      return await this.bucket.head(key);
    } catch {
      return null;
    }
  }

  /**
   * Delete an object from R2
   * Using BaseService error handling patterns
   */
  async deleteObject(key: string) {
    const logger = this.createOperationLogger('deleteObject');

    try {
      logger.debug('Deleting object from R2', { key });

      await this.bucket.delete(key);

      logger.info('Object deleted successfully', { key });
    } catch (error) {
      logger.error('Failed to delete object', error as Error, { key });
      throw this.handleError(error, 'delete object', { key });
    }
  }

  /**
   * List objects with optional filtering
   * Using BaseService error handling patterns
   */
  async listObjects(
    options: R2ListOptions = {},
    filterFn?: (obj: R2Object) => boolean,
  ): Promise<ListObjectsResult> {
    const logger = this.createOperationLogger('listObjects');

    try {
      logger.debug('Listing objects from R2', { prefix: options.prefix, limit: options.limit });

      const listed = await this.bucket.list(options);

      let objects = listed.objects.map(obj => ({
        key: obj.key,
        size: obj.size,
        etag: obj.etag,
        uploaded: obj.uploaded.toISOString(),
        metadata: parseR2CustomMetadata<R2Metadata>(obj.customMetadata),
      }));

      // Apply optional filter
      if (filterFn) {
        objects = objects.filter((obj, index) => listed.objects[index] ? filterFn(listed.objects[index]) : false);
      }

      logger.info('Objects listed successfully', { count: objects.length, truncated: listed.truncated });

      return {
        objects,
        truncated: listed.truncated,
        cursor: listed.truncated ? listed.cursor : undefined,
      };
    } catch (error) {
      logger.error('Failed to list objects', error as Error, { options });
      throw this.handleError(error, 'list objects', { options });
    }
  }

  /**
   * Check if user has access to an object
   */
  checkAccess(
    metadata: R2Metadata | undefined,
    user: User | undefined,
    session: Session | undefined,
    options: { allowPublic?: boolean } = {},
  ): AccessCheckResult {
    // No metadata means we can't verify ownership
    if (!metadata) {
      return {
        hasAccess: false,
        accessLevel: 'none',
        reason: 'No metadata available',
      };
    }

    // Check if user owns the object
    if (user?.id && metadata.userId === user.id) {
      return {
        hasAccess: true,
        accessLevel: 'owner',
      };
    }

    // Check if public access is allowed for this object
    if (options.allowPublic) {
      return {
        hasAccess: true,
        accessLevel: 'public',
      };
    }

    return {
      hasAccess: false,
      accessLevel: 'none',
      reason: 'No access permissions',
    };
  }

  /**
   * Generate a public URL for an object
   */
  generatePublicUrl(key: string, baseUrl: string): string {
    // Remove any trailing slashes from baseUrl
    const cleanBaseUrl = baseUrl.replace(/\/$/, '');
    // Ensure key doesn't start with slash
    const cleanKey = key.replace(/^\//, '');

    return `${cleanBaseUrl}/api/v1/storage/${cleanKey}`;
  }

  /**
   * Generate a signed URL for temporary access (future implementation)
   */
  async generateSignedUrl(
    key: string,
    _expiresIn: number = 3600,
  ) {
    // This would generate a signed URL for temporary access
    // Implementation depends on R2's signed URL capabilities
    // For now, return regular public URL
    return `/api/v1/storage/${key}`;
  }

  /**
   * Copy an object within the bucket
   * Using BaseService error handling patterns
   */
  async copyObject(sourceKey: string, destinationKey: string) {
    const logger = this.createOperationLogger('copyObject');

    try {
      logger.debug('Copying object in R2', { sourceKey, destinationKey });

      const source = await this.getObject(sourceKey);
      if (!source) {
        throw new HTTPException(HttpStatusCodes.NOT_FOUND, {
          message: 'Source object not found',
        });
      }

      // Get source metadata
      const sourceHead = await this.headObject(sourceKey);
      const metadata = sourceHead?.customMetadata;

      // Copy the object
      const result = await this.putObject(destinationKey, asReadableStream(source.body), {
        contentType: source.httpMetadata?.contentType,
        metadata: parseR2CustomMetadata<R2Metadata>(metadata),
      });

      logger.info('Object copied successfully', { sourceKey, destinationKey });
      return result;
    } catch (error) {
      logger.error('Failed to copy object', error as Error, { sourceKey, destinationKey });
      throw this.handleError(error, 'copy object', { sourceKey, destinationKey });
    }
  }

  /**
   * Check if an object exists
   */
  async exists(key: string) {
    const head = await this.headObject(key);
    return head !== null;
  }

  /**
   * Get storage statistics for a prefix
   */
  async getStorageStats(prefix: string) {
    let totalSize = 0;
    let objectCount = 0;
    let cursor: string | undefined;

    do {
      const result = await this.bucket.list({
        prefix,
        cursor,
        limit: 1000,
      });

      for (const obj of result.objects) {
        totalSize += obj.size;
        objectCount++;
      }

      cursor = result.truncated ? result.cursor : undefined;
    } while (cursor);

    return { totalSize, objectCount };
  }
}
