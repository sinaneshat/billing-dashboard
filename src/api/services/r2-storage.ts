/**
 * R2 Storage Service - Centralized service for all R2 bucket operations
 * Provides consistent interface, error handling, and access control
 */

// R2 types are available globally from cloudflare-env.d.ts generated by wrangler
// No need to import from @cloudflare/workers-types as they conflict
import { HTTPException } from 'hono/http-exception';
import * as HttpStatusCodes from 'stoker/http-status-codes';

import {
  asReadableStream,
  convertToR2CustomMetadata,
  parseR2CustomMetadata,
} from '@/api/common/type-utils';
import type { Session, User } from '@/lib/auth/types';

export type R2Metadata = {
  userId?: string;
  userName?: string;
  userEmail?: string;
  organizationId?: string;
  uploadedAt: string;
  purpose?: string;
  contentType?: string;
  fileSize?: string;
  originalName?: string;
  type?: string;
  requestId?: string;
  clientIp?: string;
};

export type PutObjectOptions = {
  contentType?: string;
  cacheControl?: string;
  metadata?: R2Metadata;
};

export type ListObjectsResult = {
  objects: Array<{
    key: string;
    size: number;
    etag: string;
    uploaded: string;
    metadata?: R2Metadata;
  }>;
  truncated: boolean;
  cursor?: string;
};

export type AccessCheckResult = {
  hasAccess: boolean;
  accessLevel?: 'owner' | 'organization' | 'public' | 'none';
  reason?: string;
};

/**
 * Centralized R2 Storage Service
 */
export class R2StorageService {
  constructor(private bucket: R2Bucket) {
    if (!bucket) {
      throw new Error('R2 bucket not initialized');
    }
  }

  /**
   * Create service with environment validation
   */
  static create(env: CloudflareEnv): R2StorageService {
    const bucket = env.UPLOADS_R2_BUCKET;
    if (!bucket) {
      throw new HTTPException(HttpStatusCodes.INTERNAL_SERVER_ERROR, {
        message: 'R2 bucket not bound to environment',
      });
    }
    return new R2StorageService(bucket);
  }

  /**
   * Upload an object to R2
   */
  async putObject(
    key: string,
    data: ArrayBuffer | ReadableStream,
    options: PutObjectOptions = {},
  ) {
    try {
      const httpMetadata: Record<string, string> = {};

      if (options.contentType) {
        httpMetadata.contentType = options.contentType;
      }

      if (options.cacheControl) {
        httpMetadata.cacheControl = options.cacheControl;
      } else {
        // Default cache control for private content
        httpMetadata.cacheControl = 'private, max-age=3600';
      }

      const result = await this.bucket.put(key, data, {
        httpMetadata,
        customMetadata: convertToR2CustomMetadata(options.metadata),
      });

      return result;
    } catch {
      throw new HTTPException(HttpStatusCodes.INTERNAL_SERVER_ERROR, {
        message: 'Failed to upload to storage',
      });
    }
  }

  /**
   * Get an object from R2
   */
  async getObject(key: string) {
    try {
      return await this.bucket.get(key);
    } catch {
      throw new HTTPException(HttpStatusCodes.INTERNAL_SERVER_ERROR, {
        message: 'Failed to retrieve from storage',
      });
    }
  }

  /**
   * Get object metadata without downloading the content
   */
  async headObject(key: string) {
    try {
      return await this.bucket.head(key);
    } catch {
      return null;
    }
  }

  /**
   * Delete an object from R2
   */
  async deleteObject(key: string) {
    try {
      await this.bucket.delete(key);
    } catch {
      throw new HTTPException(HttpStatusCodes.INTERNAL_SERVER_ERROR, {
        message: 'Failed to delete from storage',
      });
    }
  }

  /**
   * List objects with optional filtering
   */
  async listObjects(
    options: R2ListOptions = {},
    filterFn?: (obj: R2Object) => boolean,
  ) {
    try {
      const listed = await this.bucket.list(options);

      let objects = listed.objects.map(obj => ({
        key: obj.key,
        size: obj.size,
        etag: obj.etag,
        uploaded: obj.uploaded.toISOString(),
        metadata: parseR2CustomMetadata<R2Metadata>(obj.customMetadata),
      }));

      // Apply optional filter
      if (filterFn) {
        objects = objects.filter((obj, index) => listed.objects[index] ? filterFn(listed.objects[index]) : false);
      }

      return {
        objects,
        truncated: listed.truncated,
        cursor: listed.truncated ? listed.cursor : undefined,
      };
    } catch {
      throw new HTTPException(HttpStatusCodes.INTERNAL_SERVER_ERROR, {
        message: 'Failed to list storage objects',
      });
    }
  }

  /**
   * Check if user has access to an object
   */
  checkAccess(
    metadata: R2Metadata | undefined,
    user: User | undefined,
    session: Session | undefined,
    options: { allowPublic?: boolean } = {},
  ): AccessCheckResult {
    // No metadata means we can't verify ownership
    if (!metadata) {
      return {
        hasAccess: false,
        accessLevel: 'none',
        reason: 'No metadata available',
      };
    }

    // Check if user owns the object
    if (user?.id && metadata.userId === user.id) {
      return {
        hasAccess: true,
        accessLevel: 'owner',
      };
    }

    // Check if public access is allowed for this object
    if (options.allowPublic) {
      return {
        hasAccess: true,
        accessLevel: 'public',
      };
    }

    return {
      hasAccess: false,
      accessLevel: 'none',
      reason: 'No access permissions',
    };
  }

  /**
   * Generate a public URL for an object
   */
  generatePublicUrl(key: string, baseUrl: string): string {
    // Remove any trailing slashes from baseUrl
    const cleanBaseUrl = baseUrl.replace(/\/$/, '');
    // Ensure key doesn't start with slash
    const cleanKey = key.replace(/^\//, '');

    return `${cleanBaseUrl}/api/v1/storage/${cleanKey}`;
  }

  /**
   * Generate a signed URL for temporary access (future implementation)
   */
  async generateSignedUrl(
    key: string,
    _expiresIn: number = 3600,
  ) {
    // This would generate a signed URL for temporary access
    // Implementation depends on R2's signed URL capabilities
    // For now, return regular public URL
    return `/api/v1/storage/${key}`;
  }

  /**
   * Copy an object within the bucket
   */
  async copyObject(sourceKey: string, destinationKey: string) {
    try {
      const source = await this.getObject(sourceKey);
      if (!source) {
        throw new HTTPException(HttpStatusCodes.NOT_FOUND, {
          message: 'Source object not found',
        });
      }

      // Get source metadata
      const sourceHead = await this.headObject(sourceKey);
      const metadata = sourceHead?.customMetadata;

      // Copy the object
      return await this.putObject(destinationKey, asReadableStream(source.body), {
        contentType: source.httpMetadata?.contentType,
        metadata: parseR2CustomMetadata<R2Metadata>(metadata),
      });
    } catch {
      throw new HTTPException(HttpStatusCodes.INTERNAL_SERVER_ERROR, {
        message: 'Failed to copy object',
      });
    }
  }

  /**
   * Check if an object exists
   */
  async exists(key: string) {
    const head = await this.headObject(key);
    return head !== null;
  }

  /**
   * Get storage statistics for a prefix
   */
  async getStorageStats(prefix: string) {
    let totalSize = 0;
    let objectCount = 0;
    let cursor: string | undefined;

    do {
      const result = await this.bucket.list({
        prefix,
        cursor,
        limit: 1000,
      });

      for (const obj of result.objects) {
        totalSize += obj.size;
        objectCount++;
      }

      cursor = result.truncated ? result.cursor : undefined;
    } while (cursor);

    return { totalSize, objectCount };
  }
}
